/*
      Acronyms used in variable/control names
      txt -> text
      Txt -> Text
      len -> length
      Len -> Length
      enc -> Encrypted
      dec -> Decrypted
*/

'use strict'
const aesjs = require('aes-js')

class HesabeCrypt {
  constructor(secret, iv) {
    this.key = secret
    this.iv = iv
  }

  encryptAes(txt) {
    let paddedTxt = this.pkcs5Pad(txt)
    let txtBytes = aesjs.utils.utf8.toBytes(paddedTxt)

    let aesCbc = new aesjs.ModeOfOperation.cbc(this.key, this.iv)
    let encBytes = aesCbc.encrypt(txtBytes)

    let encHex = aesjs.utils.hex.fromBytes(encBytes)
    return encHex
  }

  decryptAes(encHex) {
    let encBytes = aesjs.utils.hex.toBytes(encHex)
    let aesCbc = new aesjs.ModeOfOperation.cbc(this.key, this.iv)
    let decBytes = aesCbc.decrypt(encBytes)
    let decTxt = aesjs.utils.utf8.fromBytes(decBytes)
    let strippedTxt = this.pkcs5Strip(decTxt)
    return strippedTxt
  }

  pkcs5Pad(txt) {
    let blockSize = 32
    let padLen = blockSize - (txt.length % blockSize)
    return txt + this.strRepeat(String.fromCharCode(padLen), padLen)
  }

  pkcs5Strip(txt) {
    var dataLen = data.length

    if (dataLen < 32) {
      throw new Error('Invalid data length. Block size must be 32 bytes')
    }
    var padderCodeInt = parseInt(data.charCodeAt(dataLen - 1))

    if (padderCodeInt > 32) {
      throw new Error('PKCS#5 padding byte out of range')
    }
    var len = dataLen - padderCodeInt

    var strippedTxt = data.substr(0, len)
    return strippedTxt
  }

  strRepeat(input, multiplier) {
    // eslint-disable-line camelcase
    let y = ''
    while (true) {
      if (multiplier & 1) {
        y += input
      }
      multiplier >>= 1
      if (multiplier) {
        input += input
      } else {
        break
      }
    }
    return y
  }
}

module.exports = HesabeCrypt
